### **Week 1: Introduction and Foundations**

- **Goals**: Understand problem-solving basics, time and space complexity, and set up an environment for LeetCode practice.
- **Topics**:
  - Introduction to Problem Solving and Complexity Analysis
  - Big O Notation Basics (O(n), O(n^2), O(log n), etc.)
- **Exercises**:
  - Practice time complexity problems on LeetCode.
  - Explore array manipulation problems for warm-up.

Here's a structured study plan for **Week 1: Introduction and Foundations**, along with suggested study materials and exercises to help you achieve your goals.

---

### **Week 1 Study Plan**

#### **Day 1: Introduction to Problem Solving and Complexity Analysis**

- **Objectives**:

  - Understand the importance of problem-solving in coding interviews.
  - Learn the fundamental concepts of complexity analysis.

- **Materials**:

  - **Video**: [Introduction to Problem Solving](https://www.youtube.com/watch?v=Gg6G21cn50k) (YouTube - Simplilearn)
  - **Article**: [What is Problem Solving?](https://www.geeksforgeeks.org/what-is-problem-solving/) (GeeksforGeeks)

- **Tasks**:
  - Take notes on key concepts: problem definition, analysis, and solution strategies.
  - Summarize the importance of problem-solving skills in programming and interviews.

---

#### **Day 2: Big O Notation Basics**

- **Objectives**:

  - Understand Big O notation and its significance in algorithm analysis.
  - Learn to calculate time complexity for various algorithms.

- **Materials**:

  - **Video**: [Big O Notation - Time Complexity](https://www.youtube.com/watch?v=__a0pIoPZGs) (YouTube - Computer Science)
  - **Article**: [Big O Notation](https://www.freecodecamp.org/news/big-o-notation-explained-with-examples/) (freeCodeCamp)

- **Tasks**:
  - Read and summarize different types of time complexities (e.g., O(1), O(n), O(n^2), O(log n)).
  - Write examples of algorithms or operations that fall into each complexity category.

---

#### **Day 3: Time Complexity Exercises**

- **Objectives**:

  - Practice applying time complexity concepts.

- **Exercises**:
  - LeetCode:
    - [Calculate the Time Complexity of an Algorithm](https://leetcode.com/discuss/general-discussion/457978/Can-you-explain-the-time-complexity-of-this-algorithm)
    - Search for problems labeled under "Easy" that focus on calculating time complexity.

---

#### **Day 4: Space Complexity Basics**

- **Objectives**:

  - Learn about space complexity and its importance.

- **Materials**:

  - **Video**: [Space Complexity in Data Structures](https://www.youtube.com/watch?v=udcH9twxw5Y) (YouTube - The Coding Train)
  - **Article**: [Space Complexity](https://www.geeksforgeeks.org/space-complexity-in-data-structures/) (GeeksforGeeks)

- **Tasks**:
  - Take notes on the definitions and examples of space complexity.
  - Identify the space complexity of common data structures (arrays, linked lists, trees).

---

#### **Day 5: Warm-up Exercises on Array Manipulation**

- **Objectives**:

  - Get comfortable with basic array operations.

- **Exercises**:
  - LeetCode:
    - [Two Sum](https://leetcode.com/problems/two-sum/)
    - [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)
    - [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
- **Tasks**:
  - Solve at least two problems focusing on array manipulation.
  - Write out your thought process before coding: plan your approach and analyze time/space complexity.

---

#### **Day 6: Review and Reflection**

- **Objectives**:

  - Consolidate your knowledge from the week.

- **Tasks**:
  - Review your notes and summaries from Days 1 to 5.
  - Reflect on what you've learned and areas where you may need additional practice.

---

#### **Day 7: Explore More Array Problems**

- **Objectives**:

  - Gain confidence with array manipulation.

- **Exercises**:
  - LeetCode:
    - [Rotate Array](https://leetcode.com/problems/rotate-array/)
    - [Plus One](https://leetcode.com/problems/plus-one/)
    - [Find the Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
- **Tasks**:
  - Solve the selected problems.
  - For each problem, analyze its time and space complexity.

---

### **Additional Resources**

- **LeetCode**: Focus on practicing "Easy" level problems, especially those under the "Array" section.
- **GeeksforGeeks**: A great source for explanations and examples of algorithms and data structures.

## By the end of Week 1, you should have a solid understanding of basic problem-solving techniques, time and space complexity, and hands-on experience with array manipulation problems. This foundation will be crucial as you progress into more complex topics and patterns in the following weeks. Happy studying!

### **Week 2: Linear Patterns - Two Pointers**

- **Goals**: Learn how to use two-pointer techniques for problems requiring linear traversal.
- **Topics**:
  - **Same Direction**: Fast and slow pointers, detecting cycles in linked lists, finding midpoints.
  - **Opposite Directions**: Pair problems, two-sum variations in sorted arrays.
- **Exercises**:
  - Practice cycle detection (e.g., "Linked List Cycle," "Middle of the Linked List").
  - Two-pointer problems on sorted arrays (e.g., "Two Sum II - Input array is sorted").
- **Project**: Solve three problems using both techniques to reinforce concepts.

---

### **Week 3: Sliding Window Pattern**

- **Goals**: Master the sliding window approach for problems with subarrays or substrings.
- **Topics**:
  - Fixed and variable-size windows
  - Tracking elements within the window using hash maps
- **Exercises**:
  - Simple problems: "Maximum Sum of Subarray of Size K," "Best Time to Buy and Sell Stock."
  - Advanced problems with variable window size: "Longest Substring Without Repeating Characters," "Minimum Window Substring."
- **Project**: Solve a problem requiring a dynamic window with hash maps.

---

### **Week 4: Binary Search**

- **Goals**: Apply binary search to sorted arrays and other monotonic functions.
- **Topics**:
  - Classic binary search for sorted arrays
  - Binary search variations (finding leftmost/rightmost occurrence)
  - Applying binary search to rotated arrays or custom conditions
- **Exercises**:
  - Basic search: "Binary Search," "Guess Number Higher or Lower."
  - Variations: "Search Insert Position," "Find Minimum in Rotated Sorted Array."
- **Project**: Design a binary search problem for a non-numeric or custom condition.

---

### **Week 5: Trees and Graphs - BFS and DFS**

- **Goals**: Understand BFS and DFS for tree and graph traversal.
- **Topics**:
  - Breadth-First Search (using queues for level-order traversal)
  - Depth-First Search (using recursion and stacks)
  - Applications in finding shortest paths, exploring nodes
- **Exercises**:
  - BFS problems: "Binary Tree Level Order Traversal," "Shortest Path in Binary Matrix."
  - DFS problems: "Binary Tree Paths," "Number of Islands."
- **Project**: Implement a basic graph traversal using BFS and DFS and solve a shortest path problem.

---

### **Week 6: Backtracking**

- **Goals**: Use backtracking to explore combinations, permutations, and solve constraint-based problems.
- **Topics**:
  - Recursive exploration of solutions
  - Backtracking with constraints and undoing choices
- **Exercises**:
  - Combination and permutation problems: "Permutations," "Subsets."
  - Constraint problems: "N-Queens," "Sudoku Solver."
- **Project**: Create a backtracking algorithm to solve a constraint-satisfaction problem.

---

### **Week 7: Priority Queues and Heaps**

- **Goals**: Learn to use heaps for efficient access to top K elements.
- **Topics**:
  - Implementing Min and Max Heaps
  - Priority queues for finding K smallest/largest elements
- **Exercises**:
  - "Kth Largest Element in an Array," "Top K Frequent Elements."
  - "Merge K Sorted Lists" to practice merging elements efficiently.
- **Project**: Solve a real-world data stream problem using a heap to track the top elements.

---

### **Week 8-9: Dynamic Programming (DP)**

- **Goals**: Build a foundation in DP with a focus on overlapping subproblems and optimal substructure.
- **Topics**:
  - **Top-Down Approach**: Memoization for recursive DP
  - **Bottom-Up Approach**: Table-filling and iteratively building solutions
  - Common DP problems: Fibonacci, knapsack problem, etc.
- **Exercises**:
  - Basic DP problems: "Fibonacci Number," "Climbing Stairs."
  - Intermediate: "House Robber," "Coin Change."
- **Project**: Solve a classic DP problem (e.g., knapsack) using both top-down and bottom-up approaches.

---

### **Week 10: Capstone Project - Mixed Patterns**

- **Goals**: Apply multiple patterns to solve complex problems and improve decision-making skills.
- **Topics**:
  - When to use multiple patterns in a single problem
  - Problem breakdown and solution design
- **Capstone Exercises**:
  - "Longest Consecutive Sequence" (using hashing and dynamic approaches)
  - "Word Ladder" (using BFS, hash maps, and dynamic window)
- **Project**: Solve an advanced problem, explaining the choice of patterns and approach.

---

### **Ongoing Practice and Advanced Tips**

- Regularly practice on LeetCode, focusing on mixed-pattern problems.
- Use algo.monster or other resources to review templates and attempt custom modifications for each problem.
